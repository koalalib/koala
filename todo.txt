A. Klasa grafu

Zadania proste:


- skoñczyæ testy szybkoœci i zdecydowaæ, na którym secie (stlowym czy vectorowym) bêdziemy pracowaæ.

- nie jestem pewien, czy po poprawkach kod bêdzie przenoœny miêdzy kompilatorami (por. uwagi Krzysztofa O.) np. nadal widzê takie stwory: Edge::V_V.

- wszystkie metody postaci get_No uzupelnic o wersje szablonowe z ostatnim parametrem chooser, a bez arg. domyslnych. Implementacja moze wykorzystywac wersje istniejace bez chooserow (banalne). W zasadzie wszystkie grupy metod get_, get_Last, get_Prev, get_Next te¿ mog¹ byæ podwojone o wersje z chooserami.

- Poprawiæ nieefektywne implementacje metod (mo¿na skorzystaæ z lokalnych tablic na stosie zamiast setów): getNeighb, getNeighNo, getClNeighb, getClNeighNo. Generalnie nie u¿ywamy setów tam, gdzie sygnatura tego nie wymaga. A nawet metody zwracaj¹ce sety (get_Set) mo¿na wykonaæ szybciej na tablicy, któr¹ finalnie sortujemy i inicjujemy seta.


- oprocz istniejacego
int getEdgeNo(Vertex*, EdgeDirection=EdAll) wprowadzamy podobn¹ metodê
int deg(Vertex*, EdgeDirection=EdAll) wyliczajac¹ getEdgeNo przy wierzcholku, ale z ew. (patrz maska) 2-krotnym zliczaniem petli (jak definiuje siê stopien w teorii grafow). Wersja szablonowa z chooserem po krawêdziach.
Ponadto metody getVertInfo(Vertex*), chVertInfo(Vertex*,VInfoType&), getEdgeInfo(Edge*), chEdgeInfo(Edge*,EInfoType&) Ale pól info w klasach Vertex/Edge nie prywatyzujemy!
Ponadto int delta(EdgeDirection=EdAll), int Delta(EdgeDirection=EdAll) - min. i max. stopien. (w rozumieniu metody deg) oraz wersje szablonowe z drugim arg. chooser i bez wartosci domyslnej. Byæ mo¿e równie¿ minVertDeg(EdgeDirection=EdAll) i maxVertDeg(EdgeDirection=EdAll) – podobne, ale z typem wyniku std::pair<int,Vertex*> - ¿eby za jednym szukaniem zwraca³y jakiœ wierzcho³ek realizuj¹cy to ekstremum.

- szablony metod grupowego usuwania lub zmieniania wierzcho³ków i krawêdzi, jako wynik zwracaj¹ liczbê udanych operacji odpowiedniego typu 
template..
int delVerts(Set<Vertex*>)
int delVerts(inputiter beg,inputiter zaend) 
int delVerts() – wszystkie, alias dla clear
int delEdges(Set<Edge*>, EdgeType=EdAll)
int delEdges(inputiter beg,inputiter zaend, EdgeType=EdAll) 
int delEdges(EdgeType=EdAll) – wszystkie, tak jak clearEdges, ale z podanym typem
int delEdges(Vertex*,Set<Edge*>, EdgeType=EdAll) – przy zadanym wierzcho³ku
int delEdges(Vertex*,inputiter beg,inputiter zaend, EdgeType=EdAll) 
int delEdges(Vertex*,EdgeType=EdAll) 
int delEdges(Vertex*, Vertex*,Set<Edge*>, EdgeType=EdAll) – i miêdzy wierzcho³kami
int delEdges(Vertex*, Vertex*,inputiter beg,inputiter zaend, EdgeType=EdAll) 
int delEdges(Vertex*, Vertex*,EdgeType=EdAll)

bool areParall(Edge*,Edge*,EdgeType) – czy s¹ równoleg³e w znaczeniu podanym przez maskê.

Edge* ch2Archs(Edge*) – zamienia krawêdŸ nieskierowan¹ na 2 przeciwrównoleg³e ³uki z tym samym info. Jedn¹ krawêdŸ zmienia, drug¹ tworzy i j¹ zwraca. 
int ch2Archs (Set<Edge*>)
int ch2Archs (inputiter beg,inputiter zaend) 
int ch2Archs () – wszystkie, 

- Trudniejsze: przezroczysta dla u¿ytkownika macierz s¹siedztwa – wystarczy u¿yæ w klasie grafu domyœlnie wynulowanego wskaŸnika na 2-wymiarow¹ tablicê asocjacyjn¹. Tablica tworzona dynamicznie. Jedyne potrzebne metody w interfejsie klasy, to:
void adjMatrix(bool on=true) // stwórz lub skasuj
bool hasAdjMatrix() // czy aktualnie klasa u¿ywa macierzy
void defragAdjMatrix();

- Potrzebne metody grafu:

Podstawienia grafu za wierzcholek - analogiczne jak copy, ale nowe wierzcholki lacza sie z sasiadami tego, ktorego zastapily
Vertex* subst(Vertex*, KoalaGraph &);
template<class VertInfoExt,class EdgeInfoExt>
Vertex* subst(Vertex*, KoalaGraph<VertInfoExt,EdgeInfoExt> &);
template<class VertInfoExt,class EdgeInfoExt,class Chooser>
Vertex* subst(Vertex*, KoalaGraph<VertInfoExt,EdgeInfoExt> &, Chooser);
template<class VertInfoExt,class EdgeInfoExt,class Chooser,class Caster>
Vertex* subst(Vertex*, KoalaGraph<VertInfoExt,EdgeInfoExt> &, Chooser, Caster);
template<class VertInfoExt,class EdgeInfoExt,class Chooser,class Caster, class Linker>
Vertex* subst(Vertex*, KoalaGraph<VertInfoExt,EdgeInfoExt> &, Chooser, Caster, Linker);

Vertex* glue(Vertex*, Vertex*, bool makeloops=false)
Vertex* glue(SetVector<Vertex*>&, bool makeloops=false, Vertex* res=NULL)
template...
Vertex* glue(inputiter beg, inputiter zaend, bool makeloops=false, Vertex* res=NULL) - skleja podane wierzcholki w jeden, laczace je krawedzie staja sie petlami lub znikaja, mozna wybrac element ze sklejanego zbioru, ktory "staje sie" wierzcholkiem wynikowym, w przeciwnym razie metoda wybiera sama jeden z zakresu.

Vertex* putVert(Edge*); - wstawia wierzcholek na podana krawedz (a ona sama znika)
Edge* takeVert(Vert*); - odwrotnie, zastepuje wierzcholek o 2 sasiadach (tylko dla takich dziala) nowa krawedzia (orientacja do dogadania, powinna byc jakos dziedziczona po znikajacych krawedziach). 

B. Uwaga: Ogólny format algorytmów jak w Dijkstrze tj. procedury z tej samej rodziny zamykamy jako metody szablonowe statyczne w klasie o charakterystycznej nazwie. Wszystkie struktury IO potrzebne tym procedurom definiujemy w klasie, równie¿ struktury potrzebne nam do dzia³ania (protected). Dane wierzcho³ków/krawêdzi w tablicach asocjacyjnych indeksowanych tymi wierzcho³kami/krawêdziami. Ci¹gi jakichkolwiek elementów zwracamy przez szablonowy iterator-wstawiacz (jak w metodzie getVerts), zaœ pobieramy z zakresu pocz¹tek-zakoniec wyznaczony dwoma podanymi iteratorami (bêdzie dzia³a³o tak ze zwyk³¹ tablic¹, jak i dowolnym kontenerem zachowuj¹cym kolejnoœæ, jak vector.assign). Póki co implementujemy tylko „sprytne” procedury wielomianowe, ¿adnych wyk³adniczych heurystyk Dyskusyjne: jak traktowaæ krawêdzie typów niedozwolonych lub bezsensownych w konkretnych zagadnieniach (np. algorytm dla grafów prostych a mamy te¿ skierowane): ignorowaæ, rzucaæ b³¹d, traktowaæ jak zwyk³e krawêdzie?

C. Makery do grafów: szablony funkcji pobieraj¹ce ref. na graf wyjœciowy (którego nie kasuj¹, tylko dopisuj¹ na koñcu, podobnie jak copy) oraz parametry liczbowe tworzonego, grafu, byæ mo¿e jakieœ parametry dodatkowe. 
template ..
Vertex* makeClique(Graph&,int n, EdgeType, VInfoGenerator= EmtyStruct<VInfo>, EInfoGenerator= EmptyStruct<EInfo>) // mo¿liwoœæ podania typów krawêdzi oraz funktorów generuj¹cych infa krawêdzi i wierzcho³ków na podstawie numerów koñcówek. Domyœlnie – generujemy wartoœci puste.

Podobne: makeEmpty, makePath, makeCycle, makeRegTree (podana arnoœæ – jak w drzewie binarnym oraz oczekiwana g³êbokoœæ), makeCompBipartite, makeCompKPartite (rozmiary partycji w podanym ci¹gu intów, na wyjœciu poza grafem dostajemy ci¹g wskaŸników do wierzcho³ków pocz¹tkowych i koñcowych tych partycji), makeFan, makeWhell, makeErdRen1, makeErdRen2 (grafy losowe o podanych prawd. krawêdzi, w tym drugim na wejœciu jest n i m). 

makeLineGraph, makeLineDigraph – poza grafem Ÿród³owym i docelowym mo¿liwoœæ podania castera i linkera ³¹cz¹cego stare krawêdzie z nowymi wierzcho³kami.

Transformery podanego grafu: makeUnderlying (kasuje orientacje krawêdzi), makeSingle (j.w. z usuniêciem równoleg³ych), makeSimple (i jeszcze wycina pêtle), makeCompletion – z parametrem EdgeType: zamienia graf na jego dope³nienie tj. kasuje krawêdzie istniej¹ce i wprowadza bez powtórzeñ te, których nie by³o w ramach krawêdzi odpowiednich typów.

Ró¿nie definiowane produkty „kartezjañskie” 2 grafów (kartezjañski, silny, leksykograficzny itd.). Warto podaæ jako parametry funktory wyznaczaj¹ce infa wierzchoków/krawêdzi wynikowych na podstawie par oryginalnych. Oczywiœcie funktory domyœlne tworz¹ infa puste.

C. Algorytmy podstawowe – wierzcho³ki grafu bez wag. 

Przeszukiwania DFS, BFS, odleg³oœæ od danego wierzcho³ka do drugiego lub wszystkich (jak w Dijkstrze), zbiór i ci¹g wierzcho³ków osi¹galnych z danego, rozbicie gr. nieskierowanego na sk³adowe spójnoœci (i ich liczba) oraz bloki (2-spójne), rozbicie skierowanego na sk³adowe silnie spójne (z relacj¹ osi¹galnoœci miêdzy nimi). Cykl i œcie¿ka Eulera dla skierowanych i nieskierowanych. Rozpoznawanie grafowej sekwencji stopni. Algorytmy dla Direct Acyclic Graphs: czy digraf jest DAGiem, jego porz¹dek topologiczny wierzcho³ków, domkniêcie przechodnie i odwrotnie – jego diagram Hassego, najd³u¿szy ³añcuch = pokrycie maksymaln¹ liczb¹ anty³añcuchów relacji czêœciowego porz¹dku (czyli kolorowanie comparability graphs z podan¹ orientacj¹), najwiêkszy anty³añcuch = pokrycie minimaln¹ liczb¹ ³añcuchów.

D. Algorytmy optymalizacji grafowej 

Dyplom p. Kamili zawiera (byæ mo¿e bêdzie trzeba siê przy³¹czyæ):
- najkrótsza œcie¿ka i drzewo œcie¿ek w wagach nieujemnych (Dijkstra) – w³aœciwie jest zrobione w przyk³adach, mo¿e dodaæ wersjê na kopcu (gotowym z STLa)
- to samo w wersji z nieujemnymi cyklami (z wykrywaniem z³ych danych): Bellman-Ford
- najl¿ejsze/najciê¿sze drzewo spinaj¹ce w nieskierowanym, las spinaj¹cy o zadanej mocy (Kruskal)
- przep³yw maksymalnej objêtoœci (Fulkerson-Ford lub coœ szybszego). Rozwi¹zanie powinno byæ zwracane razem z nasyconym rozciêciem.
- przep³yw o zadanej objêtoœci i minimalnym koszcie. Pseudowielomianowy jest ³atwy, ale najlepiej coœ wielomianowego.
- najwiêkszy matching w grafie dwudzielnym i dowolnym (wielomianowo),
- najciê¿szy/l¿ejszy matching o zadanej mocy w grafie dwudzielnym (wielomianowo), a jeœli siê uda, to i w grafie dowolnym (Edmonds).

Ponadto:
- Najwiêksze pokrycie krawêdziowe (wierzcho³ków) w grafie dowolnym i najwiêkszy zbiór niezale¿ny wierzcho³ków w dwudzielnym (z maks. matchingu). Byæ mo¿e wersje wa¿one.
- Menger theorem: najwiêkszy zbiór œcie¿ek miêdzy dwoma wierzcho³kami, roz³¹cznych krawêdziowo/wierzcho³kowo (graf bez wag i digraf). Testowanie k-spójnoœci (najlepiej ze zwracaniem minimalnego rozciêcia) wierzcho³kowej i krawêdziowej grafu i digrafu.
- Uogólnienie problemów matchingowych na faktory (podgrafy o podanym zakresie dozwolonych stopni przy wierzcho³kach).
- Uogólnienie problemów przep³ywowych na cyrkulacje i transhipments (podane ograniczenia dolne i górne dla przep³ywu na krawêdziach oraz wydajnoœci Ÿróde³/ujœæ w wierzcho³kach) – znane alfa-redukcje do przep³ywów.
- Stabilny matching w grafie dwudzielnym.

E. Szeregowanie zadañ z zale¿noœciami kolejnoœciowymi (Direct Acyclic Graph z zadaniami w wierzcho³kach):
- -|prec| - czyli szeregowanie œcie¿k¹ krytyczn¹: najd³u¿sza œcie¿ka i drzewo œcie¿ek w Direct Acyclic z wagami na krawêdziach lub wierzcho³kach.
- P|prec| - test poprawnoœci danego harmonogramu, szeregowanie listowe przy zadanej liœcie i LPT,
- P2|pi=1,prec|Cmax - Algorytm Coffmana–Grahama
- 1|pmtn,prec,rj|Lmax – zmodyfikowany Liu
- P|pj=1,in–tree|Lmax – algorytm Bruckera i szczególny przypadek: procedura Hu
oraz bez zale¿noœci prec:
- P|ri,pmtn|Lmax (z przep³ywów) i R||SigmaCi (z wa¿onego matchingu w dwudzielnym).

F. Kolorowanie klasyczne.

Wierzcho³kowe:
- zach³anne wg. podanej sekwencji wierzcho³ków (wykonaj 1 kolejny krok lub do koñca), losowa, LF, SL, Dsatur, ich wersje z interchangeami. 
- kolorowanie Brooksowe (co najwy¿ej Delta) i 5-kolorowanie planarnych (bez testu planarnoœci)
Krawêdziowe multigrafu (nawet pêtle mog¹ byæ, bo du¿o nie przeszkadzaj¹):
- zach³anne wg podanej sekwencji (wykonaj 1 kolejny krok lub do koñca), losowe, ich wersje z interchangeami, Vizingowe (co najwy¿ej Delta+multiplicity barw) i co najwy¿ej 1.5Delta.
- Brooks (Delta barw dla dwudzielnego multigrafu).

G. Rozpoznawanie i ew. dekompozycja grafów (chyba tylko prostych?)

Algorytmy ³atwe: klika, graf pusty (bez krawêdzi), las, drzewo, cykl, œcie¿ka, regularny, podkubiczny, dwudzielny (zapis obu partycji), pe³ny dwudzielny, pe³ny k-dzielny (wyznacza k oraz partycje), kaktusy (dekompozycja na boloki) i ogólniej almost tree(k) (k jest wyznaczane), chordal (perfect elimination order), split graph (on sam i dope³nienie s¹ chordal).

Nice to have: interwa³owe (test przynale¿noœci i znajdowanie reprezentacji na prostej), comparability, planarne (test przynale¿noœci, reprezentacja p³aska), zewnêtrznie planarne (jak poprzednio), krawêdziowe (rekonstrukcja pierwotnego grafu).

Algorytmy nice to have: drzewo dekompozycji modu³owej grafu (i rozpoznawanie grafów pierwszych), PQ-drzewa, wyznaczanie Dilworth number grafu, kolorowanie wierzcho³kowe, najwiêksza klika i zbiór niezale¿ny dla wymienionych klas – tam, gdzie s¹ wielomianowe.
