A. Uwaga: Ogólny format algorytmów jak w Dijkstrze tj. procedury z tej samej rodziny zamykamy jako metody szablonowe statyczne w klasie o charakterystycznej nazwie. Wszystkie struktury IO potrzebne tym procedurom definiujemy w klasie, równie¿ struktury potrzebne nam do dzia³ania (protected). Dane wierzcho³ków/krawêdzi w tablicach asocjacyjnych indeksowanych tymi wierzcho³kami/krawêdziami. Ci¹gi jakichkolwiek elementów zwracamy przez szablonowy iterator-wstawiacz (jak w metodzie getVerts), zaœ pobieramy z zakresu pocz¹tek-zakoniec wyznaczony dwoma podanymi iteratorami (bêdzie dzia³a³o tak ze zwyk³¹ tablic¹, jak i dowolnym kontenerem zachowuj¹cym kolejnoœæ, jak vector.assign). Póki co implementujemy tylko „sprytne” procedury wielomianowe, ¿adnych wyk³adniczych heurystyk Dyskusyjne: jak traktowaæ krawêdzie typów niedozwolonych lub bezsensownych w konkretnych zagadnieniach (np. algorytm dla grafów prostych a mamy te¿ skierowane): ignorowaæ, rzucaæ b³¹d, traktowaæ jak zwyk³e krawêdzie?

B. Makery do grafów: szablony funkcji pobieraj¹ce ref. na graf wyjœciowy (którego nie kasuj¹, tylko dopisuj¹ na koñcu, podobnie jak copy) oraz parametry liczbowe tworzonego, grafu, byæ mo¿e jakieœ parametry dodatkowe. 
template ..
Vertex* makeClique(Graph&,int n, EdgeType, VInfoGenerator= EmtyStruct<VInfo>, EInfoGenerator= EmptyStruct<EInfo>) // mo¿liwoœæ podania typów krawêdzi oraz funktorów generuj¹cych infa krawêdzi i wierzcho³ków na podstawie numerów koñcówek. Domyœlnie – generujemy wartoœci puste.

Podobne: makeEmpty, makePath, makeCycle, makeRegTree (podana arnoœæ – jak w drzewie binarnym oraz oczekiwana g³êbokoœæ), makeCompBipartite, makeCompKPartite (rozmiary partycji w podanym ci¹gu intów, na wyjœciu poza grafem dostajemy ci¹g wskaŸników do wierzcho³ków pocz¹tkowych i koñcowych tych partycji), makeFan, makeWhell, makeErdRen1, makeErdRen2 (grafy losowe o podanych prawd. krawêdzi, w tym drugim na wejœciu jest n i m). 

makeLineGraph, makeLineDigraph – poza grafem Ÿród³owym i docelowym mo¿liwoœæ podania castera i linkera ³¹cz¹cego stare krawêdzie z nowymi wierzcho³kami.

Transformery podanego grafu: makeUnderlying (kasuje orientacje krawêdzi), makeSingle (j.w. z usuniêciem równoleg³ych), makeSimple (i jeszcze wycina pêtle), makeCompletion – z parametrem EdgeType: zamienia graf na jego dope³nienie tj. kasuje krawêdzie istniej¹ce i wprowadza bez powtórzeñ te, których nie by³o w ramach krawêdzi odpowiednich typów.

Ró¿nie definiowane produkty „kartezjañskie” 2 grafów (kartezjañski, silny, leksykograficzny itd.). Warto podaæ jako parametry funktory wyznaczaj¹ce infa wierzchoków/krawêdzi wynikowych na podstawie par oryginalnych. Oczywiœcie funktory domyœlne tworz¹ infa puste.

C. Algorytmy podstawowe – wierzcho³ki grafu bez wag. 

Przeszukiwania DFS, BFS, odleg³oœæ od danego wierzcho³ka do drugiego lub wszystkich (jak w Dijkstrze), zbiór i ci¹g wierzcho³ków osi¹galnych z danego, rozbicie gr. nieskierowanego na sk³adowe spójnoœci (i ich liczba) oraz bloki (2-spójne), rozbicie skierowanego na sk³adowe silnie spójne (z relacj¹ osi¹galnoœci miêdzy nimi). Cykl i œcie¿ka Eulera dla skierowanych i nieskierowanych. Rozpoznawanie grafowej sekwencji stopni. Algorytmy dla Direct Acyclic Graphs: czy digraf jest DAGiem, jego porz¹dek topologiczny wierzcho³ków, domkniêcie przechodnie i odwrotnie – jego diagram Hassego, najd³u¿szy ³añcuch = pokrycie maksymaln¹ liczb¹ anty³añcuchów relacji czêœciowego porz¹dku (czyli kolorowanie comparability graphs z podan¹ orientacj¹), najwiêkszy anty³añcuch = pokrycie minimaln¹ liczb¹ ³añcuchów.

D. Algorytmy optymalizacji grafowej 

Dyplom p. Kamili zawiera (byæ mo¿e bêdzie trzeba siê przy³¹czyæ):
- najkrótsza œcie¿ka i drzewo œcie¿ek w wagach nieujemnych (Dijkstra) – w³aœciwie jest zrobione w przyk³adach, mo¿e dodaæ wersjê na kopcu (gotowym z STLa)
- to samo w wersji z nieujemnymi cyklami (z wykrywaniem z³ych danych): Bellman-Ford
- najl¿ejsze/najciê¿sze drzewo spinaj¹ce w nieskierowanym, las spinaj¹cy o zadanej mocy (Kruskal)
- przep³yw maksymalnej objêtoœci (Fulkerson-Ford lub coœ szybszego). Rozwi¹zanie powinno byæ zwracane razem z nasyconym rozciêciem.
- przep³yw o zadanej objêtoœci i minimalnym koszcie. Pseudowielomianowy jest ³atwy, ale najlepiej coœ wielomianowego.
- najwiêkszy matching w grafie dwudzielnym i dowolnym (wielomianowo),
- najciê¿szy/l¿ejszy matching o zadanej mocy w grafie dwudzielnym (wielomianowo), a jeœli siê uda, to i w grafie dowolnym (Edmonds).

Ponadto:
- Najwiêksze pokrycie krawêdziowe (wierzcho³ków) w grafie dowolnym i najwiêkszy zbiór niezale¿ny wierzcho³ków w dwudzielnym (z maks. matchingu). Byæ mo¿e wersje wa¿one.
- Menger theorem: najwiêkszy zbiór œcie¿ek miêdzy dwoma wierzcho³kami, roz³¹cznych krawêdziowo/wierzcho³kowo (graf bez wag i digraf). Testowanie k-spójnoœci (najlepiej ze zwracaniem minimalnego rozciêcia) wierzcho³kowej i krawêdziowej grafu i digrafu.
- Uogólnienie problemów matchingowych na faktory (podgrafy o podanym zakresie dozwolonych stopni przy wierzcho³kach).
- Uogólnienie problemów przep³ywowych na cyrkulacje i transhipments (podane ograniczenia dolne i górne dla przep³ywu na krawêdziach oraz wydajnoœci Ÿróde³/ujœæ w wierzcho³kach) – znane alfa-redukcje do przep³ywów.
- Stabilny matching w grafie dwudzielnym.

E. Szeregowanie zadañ z zale¿noœciami kolejnoœciowymi (Direct Acyclic Graph z zadaniami w wierzcho³kach):
- -|prec| - czyli szeregowanie œcie¿k¹ krytyczn¹: najd³u¿sza œcie¿ka i drzewo œcie¿ek w Direct Acyclic z wagami na krawêdziach lub wierzcho³kach.
- P|prec| - test poprawnoœci danego harmonogramu, szeregowanie listowe przy zadanej liœcie i LPT,
- P2|pi=1,prec|Cmax - Algorytm Coffmana–Grahama
- 1|pmtn,prec,rj|Lmax – zmodyfikowany Liu
- P|pj=1,in–tree|Lmax – algorytm Bruckera i szczególny przypadek: procedura Hu
oraz bez zale¿noœci prec:
- P|ri,pmtn|Lmax (z przep³ywów) i R||SigmaCi (z wa¿onego matchingu w dwudzielnym).

F. Kolorowanie klasyczne.

Wierzcho³kowe:
- zach³anne wg. podanej sekwencji wierzcho³ków (wykonaj 1 kolejny krok lub do koñca), losowa, LF, SL, Dsatur, ich wersje z interchangeami. 
- kolorowanie Brooksowe (co najwy¿ej Delta) i 5-kolorowanie planarnych (bez testu planarnoœci)
Krawêdziowe multigrafu (nawet pêtle mog¹ byæ, bo du¿o nie przeszkadzaj¹):
- zach³anne wg podanej sekwencji (wykonaj 1 kolejny krok lub do koñca), losowe, ich wersje z interchangeami, Vizingowe (co najwy¿ej Delta+multiplicity barw) i co najwy¿ej 1.5Delta.
- Brooks (Delta barw dla dwudzielnego multigrafu).

G. Rozpoznawanie i ew. dekompozycja grafów (chyba tylko prostych?)

Algorytmy ³atwe: klika, graf pusty (bez krawêdzi), las, drzewo, cykl, œcie¿ka, regularny, podkubiczny, dwudzielny (zapis obu partycji), pe³ny dwudzielny, pe³ny k-dzielny (wyznacza k oraz partycje), kaktusy (dekompozycja na boloki) i ogólniej almost tree(k) (k jest wyznaczane), chordal (perfect elimination order), split graph (on sam i dope³nienie s¹ chordal).

Nice to have: interwa³owe (test przynale¿noœci i znajdowanie reprezentacji na prostej), comparability, planarne (test przynale¿noœci, reprezentacja p³aska), zewnêtrznie planarne (jak poprzednio), krawêdziowe (rekonstrukcja pierwotnego grafu).

Algorytmy nice to have: drzewo dekompozycji modu³owej grafu (i rozpoznawanie grafów pierwszych), PQ-drzewa, wyznaczanie Dilworth number grafu, kolorowanie wierzcho³kowe, najwiêksza klika i zbiór niezale¿ny dla wymienionych klas – tam, gdzie s¹ wielomianowe.
